The root cause of CVE-2018-13785 in libpng 1.6.34 is related to an incorrect computation of `row_factor` in the `png_check_chunk_length` function, as found in the file `pngrutil.c`. This miscalculation could lead to an integer overflow when the `row_factor` value, which is intended to represent the size of a row in bytes (considering the image's width, bit depth, and whether it's interlaced), becomes too large. Once this overflow occurs, it consequently could trigger a divide-by-zero situation when the program attempts to use `row_factor` in calculations related to processing image data. 

Divide-by-zero errors are critical as they can crash programs or processes, leading to a denial of service (DoS). In this specific case, when a specially crafted PNG file is processed, it exploits this vulnerability, potentially causing the application utilizing libpng to crash.

The error stems from the way `row_factor` was originally calculated. In the vulnerable code, the calculation does not safely cast the involved variables to a larger data type that can hold the result without overflowing. Given that `png_ptr->width`, `png_ptr->channels`, and the expression `(png_ptr->bit_depth > 8? 2: 1)` are multiplied together, this product could exceed the size that can be stored in a `size_t` variable on systems where `size_t` is equivalent to `png_uint_32` (a 32-bit unsigned integer).

The patch corrects this by ensuring each operand involved in the multiplication is explicitly cast to `size_t` before the operation, helping to prevent the integer overflow. This way, if the operations result in a value that exceeds the range of a 32-bit integer, it can be safely accommodated within the `size_t` type (assuming `size_t` is larger, which is typically the case in 64-bit systems).

Furthermore, the patch includes another safety check for the value of `row_factor` against `PNG_UINT_32_MAX`, considering the height of the image to ensure that the total number of bytes required for the image does not exceed the maximum allowable limit. This additional check helps in preventing other potential overflows when calculating the memory required for the image's data.